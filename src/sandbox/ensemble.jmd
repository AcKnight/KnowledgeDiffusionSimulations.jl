
```julia
using DifferentialEquations, StatsBase, Parameters, Plots, Interact, Distributions
```

### Jump Problem Setup

```julia
function affect!(integrator)
  n = rand(1:integrator.p.N)
  n2 = rand(1:integrator.p.N)
  integrator.u[n] = max(integrator.u[n], integrator.u[n2])
end

function μ_SDE(du,u,p,t)
  du .= p.μ
end

function σ_SDE(du,u,p,t)
  du .= p.σ
end
```

```julia
params = @with_kw (
    μ = 0.01, # mean
    σ = 0.1, # drift
    N = 10, # num particles
    β = 0.2, # rate parameter
    t = 0.:0.01:10., # time steps to save
    moments = Array{Array{Float64, 1}, 1}(), # container for moments
    α = 2.0, # shape parameter for the initial condition distribution
    iv_dist = Exponential(1/α)) # updates based on supplied α

p = params()
```

```julia
x_iv = rand(p.iv_dist, p.N)  # draws the inital condition
prob = SDEProblem(μ_SDE, σ_SDE, x_iv ,(0.0, p.t[end]), p)
rate(u,p,t) = p.β*p.N
jump = ConstantRateJump(rate,affect!)
jump_prob = JumpProblem(prob,Direct(),jump)
```

### Callback Setup

```julia
function calculate_moments(u, t, integrator) 
    g = (length(integrator.p.moments) == 0 ? 0. : (mean(u) - integrator.p.moments[end][2])/step(integrator.p.t))
    moments = [minimum(u), mean(u), maximum(u), g]
    push!(integrator.p.moments, moments) 
end

cb = FunctionCallingCallback(calculate_moments; funcat=p.t, func_everystep=false, func_start = true, tdir=1)
    
function write_moments(sol, i)
    resize!(sol.t, 0); resize!(sol.u, 0)
    append!(sol.t, sol.prob.p.t); append!(sol.u, sol.prob.p.moments)
    return (sol, false)
end
```

```julia
ensemble_prob = EnsembleProblem(prob, output_func = write_moments)
```

### Solve and Plot

```julia
sim = solve(ensemble_prob, SRIW1(), EnsembleSerial(), trajectories = 2, callback = cb, save_everystep = false)
```

```julia
summ = EnsembleSummary(sim)
```

```julia
p1 = plot(summ, idxs = [1], error_style = :none, title = "Min")
p2 = plot(summ, idxs = [2], error_style = :none, title = "Mean")
p3 = plot(summ, idxs = [3], error_style = :none, title = "Max")
p4 = plot(summ, idxs = [4], error_style = :none, title = "Growth")

plot(p1, p2, p3, p4)
```

### Single Simulation

With some slight modification, we can follow the particle trajectories within a single simulation.

```julia
sol = solve(jump_prob, SRIW1(), saveat = p.t); # output is quite long when printed
```

We show only half of the particles, for ease of display.

```julia
plot(sol(p.t, idxs=[2, 4, 6, 8, 10]), legend = false, title = "Particle Trajectories for Even # Particles")
```
